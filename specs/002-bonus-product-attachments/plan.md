# Implementation Plan: Bonus Product Attachments

**Branch**: `002-bonus-product-attachments` | **Date**: 2025-10-20 | **Spec**: `specs/002-bonus-product-attachments/spec.md`
**Input**: Feature specification from `/specs/002-bonus-product-attachments/spec.md`

## Summary

Deliver merchant-managed bonus product attachments that surface in the checkout messaging engine, highlight the value of subscriptions, and keep inventory counts accurate. Work spans the admin Messaging Console (product picker, validation, persistence), the checkout extension (rendering bonus card with Money-safe formatting and localization), and the post-checkout webhook to track inventory for included items without double-counting sales.

## Technical Context

**Language/Version**: TypeScript (Node 20+, React Router 7, Preact 10)
**Primary Dependencies**: `@shopify/shopify-app-react-router`, Prisma ORM, `@shopify/ui-extensions/preact`, `@shopify/polaris-types`, Zod, Shopify Admin GraphQL API
**Storage**: Prisma -> SQLite in dev, PostgreSQL-compatible schema for production
**Testing**: Vitest with Testing Library for admin UI, Vitest + Prisma test client for services, mock checkout harness for extension logic
**Target Platform**: Shopify embedded admin (desktop/mobile web) and Checkout UI Extension API 2025-10
**Project Type**: Web monorepo (admin app plus checkout extension)
**Performance Goals**: Checkout render under 100 ms, admin save response under 200 ms, webhook completion under 2 s
**Constraints**: Must honor Money object handling, localization (en and fr), and Polaris web components; bundle increase < 10 KB gzip; optional chaining everywhere data crosses Shopify boundary
**Scale/Scope**: One attachment per subscription rule in MVP (annual and quarterly) with room to extend to three attachments in future; supports thousands of orders per day without missing inventory adjustments

## Constitution Check

- ✅ Principle I (Shopify Approval Compliance): Plan enforces optional chaining, error boundaries, and localized copy updates before deploy.
- ✅ Principle II (Checkout Extension Integrity): Extension work keeps Preact render pattern, Money object access, and bundle budget under 80 KB.
- ✅ Principle III (Documentation Driven Delivery): Deliverables include research, data model, quickstart, locale updates, and implementation status log.
- ✅ Principle IV (Verification and Observability): Testing strategy covers unit, UI, webhook retries, and audit logging with evidence stored in docs.
- ✅ Principle V (Privacy and Configuration Ownership): Merchant-driven configuration via Prisma, no PII leaves Shopify, inventory logs tagged without customer data.

## Project Structure

### Documentation (this feature)

```
specs/002-bonus-product-attachments/
├── plan.md
├── research.md
├── data-model.md
├── quickstart.md
├── contracts/
│   └── bonus-attachments.graphql
└── tasks.md               # Generated by /speckit.tasks
```

### Source Code (repository root)

```
app/
├── routes/
│   ├── app._index.tsx                # Extend loader/action for attachment CRUD
│   ├── app.messaging.attachments.tsx # NEW route segment for attachment form UI
│   ├── webhooks.orders-paid.tsx      # NEW webhook handler for inventory tracking
│   └── api/
│       └── attachments.save.ts       # NEW JSON endpoint (if decoupled from loader)
├── components/
│   └── attachments/
│       ├── BonusAttachmentForm.tsx   # NEW Polaris web component wrapper
│       └── AttachmentPreview.tsx     # NEW preview card fragment
├── services/
│   └── messaging-bonus.server.ts     # NEW Prisma + validation service layer

extensions/nudun-messaging-engine/src/
├── components/
│   └── BonusAttachmentCard.jsx       # NEW Preact component for checkout banner
├── hooks/
│   └── useBonusAttachment.js         # NEW hook reading storage/metafield payload
└── storage/
    └── bonusAttachmentSource.js      # NEW adapter for extension storage entry

prisma/
└── schema.prisma                     # Extend with MessagingBonusAttachment table

docs/
├── user-guides/
│   └── bonus-attachments.md          # NEW merchant guide with screenshots
└── testing/
    └── TESTING-BONUS-ATTACHMENTS.md  # NEW QA evidence log

tests/
├── admin/
│   └── bonus-attachments.test.tsx    # NEW Vitest UI coverage
├── services/
│   └── messaging-bonus.server.test.ts# NEW service validation tests
└── webhooks/
    └── orders-paid.test.ts           # NEW webhook idempotency tests
```

**Structure Decision**: Extend existing React Router admin routes and Prisma services, add focused components under `components/attachments`, and keep checkout extension logic scoped to new component and hook files. Documentation and tests mirror existing project layout for consistency.

## Complexity Tracking

| Violation | Why Needed | Simpler Alternative Rejected Because |
|-----------|------------|-------------------------------------|
| None | Plan aligns with constitutional constraints | N/A |

## Milestones and Deliverables

### Phase 0 - Research and Alignment (1 day)
- Interview existing messaging service code to catalog touchpoints for bonus data (Prisma services, loaders, extension storage).
- Validate Shopify Admin GraphQL product picker patterns and required scopes.
- Document Money object handling needs (variant price, compare-at price, exchange rates) and localization behaviors.

**Exit Criteria**: `research.md` populated with findings, open questions narrowed to business decisions only, no constitutional blockers remaining.

### Phase 1 - Data Model and Contracts (2 days)
- Extend Prisma schema with `MessagingBonusAttachment` and publish migration plan.
- Define attachment DTOs and validation schemas (Zod) for admin save and extension read operations.
- Produce `contracts/bonus-attachments.graphql` describing queries/mutations for product picker and admin persistence.
- Author `data-model.md` capturing relationships, indexing, and idempotency keys.

**Exit Criteria**: Migration reviewed, validation schemas unit tested, constitution check re-run (documentation updated where required).

### Phase 2 - Admin Console UX (3 days)
- Build `app.messaging.attachments.tsx` route with loader/action using `authenticate.admin()`.
- Implement `BonusAttachmentForm` component with Shopify Polaris web components and product picker integration.
- Add list/table for existing attachments, reset-to-defaults control, and audit log updates.
- Ensure localization strings and translations added to `locales/en.default.json` and `locales/fr.json`.

**Exit Criteria**: Admin UI persists attachment, validation errors surfaced, Vitest coverage >= 80 percent for form logic, screenshots captured for docs.

### Phase 3 - Checkout Extension Rendering (2 days)
- Create `BonusAttachmentCard.jsx` component and supporting hook to read attachment payload from extension storage fetch (REST or GraphQL call).
- Apply Money pattern conversions (`amount`, `currencyCode`) and optional chaining; add fallback when attachment missing or image fails.
- Update extension bundle to include new component while staying under size budget; add locale-aware copy.

**Exit Criteria**: Extension preview shows attachment in dev store, bundle diff < 10 KB gzip, manual test plan updated.

### Phase 4 - Inventory Attribution Webhook (2 days)
- Add `webhooks.orders-paid.tsx` (or extend existing webhook) to adjust inventory via Admin API with `included_bonus` tag.
- Implement idempotency guard (orderId + attachmentId) and retry strategy with exponential backoff.
- Log adjustments to `ConfigAuditLog` and provide observability hooks for failure monitoring.

**Exit Criteria**: Webhook passes unit tests and manual replay (Shopify CLI), retries verified, logs visible in development.

### Phase 5 - QA, Documentation, and Launch (1 day)
- Draft `quickstart.md` and merchant guide; update `IMPLEMENTATION-STATUS.md` and relevant testing docs.
- Finalize localization review (hand off to translation if needed).
- Run lint, typecheck, Vitest suite, and extension build; archive evidence in `docs/testing/`.

**Exit Criteria**: Documentation approved, checklist satisfied, go-no-go review complete.

## Data and API Changes
- **Prisma**: Add `MessagingBonusAttachment` table with indexes on `configId` and `(orderId, attachmentId)` idempotency key; adjust existing services to return attachments.
- **Admin Loader/Action**: Extend `app._index.tsx` loader and action or introduce scoped API route to read/write attachments with Zod validation.
- **Product Picker**: Issue Admin GraphQL queries for product and variant selection; cache results to avoid rate limit hits.
- **Extension Payload**: Expand merchant config endpoint or metafield to include `bonusAttachment` object with product metadata, image URL, and localized copy.
- **Webhook**: New `/webhooks/orders-paid` handler (or extension of existing orders webhook) adjusting inventory using Admin REST `inventory_levels/adjust` or GraphQL `inventoryAdjustQuantity` mutation with retry logging.

## Testing Strategy
- **Unit**: Vitest tests for Prisma service (create/update/delete attachment, idempotency guard), webhook retry helper, and Money formatting utilities.
- **Component**: React Testing Library for `BonusAttachmentForm` validating field rules, localization fallback, and reset behavior.
- **Integration**: Mock checkout execution verifying extension renders attachment when storage populated, plus webhook integration test hitting mocked Shopify API.
- **Manual QA**: Dev store walkthrough covering admin attach, checkout preview, order completion, and Shopify admin inventory check; record in `TESTING-BONUS-ATTACHMENTS.md`.
- **Automation Hooks**: Wire tests into `npm run typecheck`, `npm run lint`, and dedicated `npm run test:bonus` (to be added if load warrants).

## Observability and Audit
- Augment `ConfigAuditLog` entries with attachment metadata and actor info when merchants create, update, or reset attachments.
- Log webhook outcomes (success, retry, failure) with structured JSON and correlation IDs for replay.
- Add optional debug toggle in admin console to surface latest webhook status for merchant support.

## Documentation Deliverables
- `research.md`, `data-model.md`, `quickstart.md`, and `contracts/bonus-attachments.graphql` committed.
- New merchant guide `docs/user-guides/bonus-attachments.md` with annotated screenshots and localization notes.
- Update `IMPLEMENTATION-STATUS.md`, `SHOPIFY-APPROVAL-CHECKLIST.md`, and any relevant troubleshooting guides.
- Localization placeholders for new copy in `locales/fr.json` with TODO markers for translation review.

## Risks and Mitigations
- **Inventory API rate limits**: Batch adjustments and exponential backoff; document fallback to manual reconciliation if repeated failures occur.
- **Product picker inconsistencies**: Cache selection, provide fallback text field for SKU lookup, and validate that selected product remains published.
- **Localization gaps**: Enforce translation placeholders before merge and include fallback copy logic in extension.
- **Webhook downtime**: Persist adjustments in retry queue table and surface admin alert when retries exceed threshold.

## Dependencies and Coordination
- Align with product owner on bonus product defaults and copy style.
- Confirm Shopify API scopes cover inventory adjustments (`write_inventory` or equivalent); update `shopify.app.toml` if missing.
- Coordinate with analytics team if bonus attachment impressions/clicks instrumented later (Phase 3 roadmap).
- Validate translation timeline with localization partner for French updates.

## Open Questions
1. Should savings value use compare-at price when available instead of base price?
2. Which webhook event offers most reliable timing (`orders/paid` vs `orders/fulfilled`)?
3. Do we need to expose attachment analytics now or wait for Phase 3 analytics framework?
4. Are merchants allowed to attach different products per locale, or is copy translation sufficient?

## Next Steps
1. Author `research.md`, `data-model.md`, `quickstart.md`, and initial contract stub following Phase 0 and 1 outputs.
2. Review plan with engineering lead and product owner; adjust timelines or scope if blockers arise.
3. After approval, run `/speckit.tasks bonus-product-attachments` to generate executable tasks and move into implementation.

